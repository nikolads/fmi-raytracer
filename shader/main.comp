#version 450
#extension GL_ARB_separate_shader_objects : enable

const int WIDTH = 800;
const int HEIGHT = 600;
const int WORKGROUP_SIZE = 32;
const int N_RAYS = 8;
layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;
layout(binding = 0, rgba32f) restrict uniform image2D work_image;

const float PI = 3.14159265358979323846264338327950288;

uint RNG_STATE = 0;

float sin_rand() {
    vec2 co = vec2(float(gl_LocalInvocationIndex), float(RNG_STATE));
    RNG_STATE += 1;

    float dt = dot(co.xy, vec2(12.9898, 78.233));
    float sn = mod(dt, PI);
    return fract(sin(sn) * 43758.5453);
}

float sq(float x) {
    return x * x;
}

/// Pick a random point in the unit disc with uniform probability.
vec2 unit_disc_sample() {
    float angle = sin_rand() * 2.0 * PI;
	float r = sqrt(sin_rand());

    float x = r * sin(angle);
    float y = r * cos(angle);

	return vec2(x, y);
}

/// Generates a random orthonormal basis based on an input vector.
///
/// Generates vectors `ray1` and `ray2` such that together with `in_ray` they
/// form an orthonormal system in 3D (all vectors are unit, and are mutually orthogonal).
///
/// `in_ray` must be a unit vector.
void orthonormal_system(vec3 in_ray, out vec3 ray1, out vec3 ray2) {
	const vec3 FIXED_SAMPLES[2] = vec3[2](
        vec3(-0.267261242, +0.534522484, -0.801783726),
		vec3(+0.483368245, +0.096673649, +0.870062840)
    );

	if (abs(dot(in_ray, FIXED_SAMPLES[0])) < 0.99) {
        ray1 = normalize(cross(in_ray, FIXED_SAMPLES[0]));
        ray2 = normalize(cross(in_ray, ray1));
    } else {
        ray1 = normalize(cross(in_ray, FIXED_SAMPLES[1]));
        ray2 = normalize(cross(in_ray, ray1));
    }
}

// uses Schlick's approximation
vec3 specular_reflection(vec3 color, vec3 w_in, vec3 normal) {
    float cos_term = 1 - dot(w_in, normal);
    float cos_term_pow2 = cos_term * cos_term;
    float cos_term_pow4 = cos_term_pow2 * cos_term_pow2;
    float cos_term_pow5 = cos_term_pow4 * cos_term;

    return color + (1 - color) * cos_term_pow5;
}

struct Ray {
    vec3 start;
    vec3 dir;
};

Ray screen_ray(uvec2 pixel);

struct IntersectionInfo {
    int object;
    vec3 point;
    float dist;
};

IntersectionInfo trace_ray(Ray ray);

struct Material {
    /// Diffuse color.
    ///
    /// Ratio between the energy of light which is scattered back from the interior
    /// of the object to the energy which is absorbed. Used to model local subsurface
    /// scattering.
    ///
    /// Must be between 0.0 and 1.0.
    vec3 diff_color;

    /// Color of specular reflections.
    ///
    /// This is a specific constant for each material and is the value of the
    /// Fresnel equations evaluated at 0 degrees. Depends on the index of refraction
    /// of the material and the surrounding medium.
    ///
    /// Must be between 0.0 and 1.0.
    vec3 spec_color;

    /// Index of refraction of the material.
    ///
    /// Should be compatible with `spec_color`.
    /// Used for refracting rays through transperent materials.
    float refr_index;

    /// Arbitrary parameter for specular reflections.
    ///
    /// Determines how rough the surface of the material is at the microscopic level.
    /// Higher values mean smoother and more reflective material.
    ///
    /// Must be between 0.0 and +inf.
    float roughness;
};

vec3 material_brdf(Material material, vec3 w_in, vec3 w_out, vec3 normal);
void material_spawn_ray(Material material, vec3 w_in, vec3 normal, out vec3 w_out, out vec3 color_mult);
float material_ndf(Material material, float cos_angle);
void material_ndf_sample(Material material, vec3 normal, out vec3 sampled, out float prob);

struct Object {
    mat4 transform;
    mat4 inv_transform;
    Material material;
};

vec3 sphere_normal(Object sphere, vec3 point);
bool sphere_intersect(Object sphere, Ray ray, out vec3 intersection_point);

struct PointLight {
    vec3 pos;
    vec3 color;
};

vec3 point_light_sample(PointLight light);

const Object SPHERES[2] = Object[2](
    Object(
        mat4(
            0.3, 0.0, 0.0, 0,
            0.0, 0.3, 0.0, 0,
            0.0, 0.0, 0.3, 0,
            -0.4, -0.2, 1.5, 1
        ),
        mat4(
            3.33333, 0.0, 0.0, 0,
            0.0, 3.33333, 0.0, 0,
            0.0, 0.0, 3.33333, 0,
            1.33333, 0.66667, -5, 1
        ),
        Material(vec3(0.0, 0.0, 0.0), vec3(1.00, 0.71, 0.29), 10, 16)
    ),
    // Object(
    //     mat4(
    //         0.2, 0.0, 0.0, 0,
    //         0.0, 0.2, 0.0, 0,
    //         0.0, 0.0, 0.2, 0,
    //         -0.5, -0.2, 1.5, 1
    //     ),
    //     mat4(
    //         5, 0.0, 0.0, 0,
    //         0.0, 5, 0.0, 0,
    //         0.0, 0.0, 5, 0,
    //         2.5, 1, -7.5, 1
    //     ),
    //     Material(1000, 0.0, vec3(0, 0, 0))
    // ),
    Object(
        mat4(
            0.3, 0.0, 0.0, 0,
            0.0, 0.3, 0.0, 0,
            0.0, 0.0, 0.3, 0,
            0.4, -0.2, 1.5, 1
        ),
        mat4(
            3.33333, 0.0, 0.0, 0,
            0.0, 3.33333, 0.0, 0,
            0.0, 0.0, 3.33333, 0,
            -1.33333, 0.66667, -5, 1
        ),
        Material(vec3(0.8, 0.2, 0.2), vec3(0.05, 0.05, 0.05), 10, 8)
    )
);

const PointLight LIGHTS[1] = PointLight[1](
    PointLight(vec3(0, -1, 0), vec3(1.5, 1.5, 1.5))
    // PointLight(vec3(-0.9, -0.9, 0.6), vec3(1, 1, 3))
);

void main() {
    // In order to fit the work into workgroups, some unnecessary threads are launched.
    if (gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT) { return; }

    RNG_STATE = gl_GlobalInvocationID.z * 1000;

    Ray ray = screen_ray(gl_GlobalInvocationID.xy);
    vec3 out_color = vec3(0.0, 0.0, 0.0);
    vec3 light_mult = vec3(1.0, 1.0, 1.0);

    const vec3 BACKGROUND_COLOR = vec3(0.05, 0.05, 0.05);
    const uint MAX_DEPTH = 4;

    for (uint i = 0; i < MAX_DEPTH; i++) {
        IntersectionInfo intersect = trace_ray(ray);

        if (intersect.object == -1) {
            out_color += BACKGROUND_COLOR * light_mult;
            break;
        }

        Object obj = SPHERES[intersect.object];
        vec3 obj_normal = sphere_normal(obj, intersect.point);

        // Trace ray from intersection to a light source
        vec3 light_sample = point_light_sample(LIGHTS[0]);
        float dist_to_light = distance(light_sample, intersect.point);
        Ray light_ray = Ray(intersect.point + 0.000061035 * obj_normal, normalize(light_sample - intersect.point));
        IntersectionInfo light_intersect = trace_ray(light_ray);

        if (dist_to_light < light_intersect.dist) {
            vec3 brdf_color = material_brdf(obj.material, -ray.dir, light_ray.dir, obj_normal);
            out_color += LIGHTS[0].color * brdf_color * light_mult * dot(light_ray.dir, obj_normal);
        }

        // Continue tracing the original ray
        vec3 w_out;
        vec3 color_mult;
        material_spawn_ray(obj.material, -ray.dir, obj_normal, w_out, color_mult);

        ray = Ray(intersect.point + 0.000061035 * w_out, w_out);
        light_mult *= color_mult;
    }

    out_color /= float(N_RAYS);

    vec4 image_color = imageLoad(work_image, ivec2(gl_GlobalInvocationID.xy));
    imageStore(work_image, ivec2(gl_GlobalInvocationID.xy), image_color + vec4(out_color, 0.0));
}

Ray screen_ray(uvec2 pixel) {
    const float ASPECT_RATIO = float(HEIGHT) / float(WIDTH);

    vec3 origin = vec3(
        (-1.0 + float(pixel.x) / float(WIDTH) * 2.0),
        (-1.0 + float(pixel.y) / float(HEIGHT) * 2.0) * ASPECT_RATIO,
        0.0
    );

    // TODO: -Z should be calculated from FoV
    vec3 dir = normalize(origin - vec3(0.0, 0.0, -10.0));

    return Ray(origin, dir);
}

IntersectionInfo trace_ray(Ray ray) {
    IntersectionInfo info = IntersectionInfo(-1, vec3(0, 0, 0), 1.0 / 0.0);

    for (uint i = 0; i < SPHERES.length(); i++) {
        Object object = SPHERES[i];
        vec3 intersection_point;

        if (sphere_intersect(object, ray, intersection_point)) {
            float dist_to_intersection = distance(ray.start, intersection_point);

            if (dist_to_intersection < info.dist) {
                info = IntersectionInfo(int(i), intersection_point, dist_to_intersection);
            }
        }
    }

    return info;
}

/// Calculate brdf value.
///
/// Uses the Lambertian model for local subsurface scattering
/// and the Blinn-Phong model for specular reflection.
vec3 material_brdf(Material material, vec3 w_in, vec3 w_out, vec3 normal) {
    if (dot(w_in, normal) < 0 || dot(w_out, normal) < 0) {
        return vec3(0.0, 0.0, 0.0);
    }

    vec3 halfv = normalize(w_in + w_out);
    vec3 spec = specular_reflection(material.spec_color, w_in, halfv);
    vec3 diff = (1 - spec) * material.diff_color;
    float ndf = material_ndf(material, dot(normal, halfv));

    return (1 / PI) * diff + ndf * spec;
}

void material_spawn_ray(Material material, vec3 w_in, vec3 normal, out vec3 w_out, out vec3 color_mult) {
    // TODO: model refraction

    vec3 refl_prob = specular_reflection(material.spec_color, w_in, normal);

    vec3 mod_normal;
    float mod_prob;
    material_ndf_sample(material, normal, mod_normal, mod_prob);

    w_out = reflect(-w_in, mod_normal);
    color_mult = refl_prob * mod_prob;
}

/// Normal distribution function.
///
/// An NDF describes what the microgeometry of a surface looks like statistically.
/// For a given angle θ it shows what part of the microfacets have a normal
/// at a θ angle to the surface normal.
float material_ndf(Material material, float cos_angle) {
    float m = material.roughness;
    return (m + 8) / (8 * PI) * pow(cos_angle, m);
}

/// Get a random vector in a hemisphere above `normal`, with a probability determined by the NDF.
void material_ndf_sample(Material material, vec3 normal, out vec3 sampled, out float prob) {
    float m = material.roughness;

    // Ideally we would want to sample with the same probability as the NDF.
    // However this will make the calculation too expensive.

    // Here a very crude approximation is used - the unit disk is cut up to
    // radius < f(m), then a uniform sample is taken from the rest.
    float cutoff = 1 / (1.0 + m);
    vec2 point = unit_disc_sample() * cutoff;

    vec3 e2, e3;
    orthonormal_system(normal, e2, e3);

    sampled = normalize(normal + point.x * e2 + point.y * e3);
    prob = material_ndf(material, dot(normal, sampled));
}

bool sphere_intersect(Object sphere, Ray ray, out vec3 intersection_point) {
    Ray norm_ray = Ray(
        (sphere.inv_transform * vec4(ray.start, 1.0)).xyz,
        normalize((sphere.inv_transform * vec4(ray.dir, 0.0)).xyz)
    );

    // X^2 + X * 2 * dot(start, dir) + dot(start, start) - 1 = 0
    float a = 1.0;
    float b = 2 * dot(norm_ray.start, norm_ray.dir);
    float c = dot(norm_ray.start, norm_ray.start) - 1;
    float disc = b*b - 4*a*c;

    if (disc < 0) { return false; }

    float sqrt_disc = sqrt(disc);
    float smaller = (-b - sqrt_disc) / (2 * a);
    float larger = (-b + sqrt_disc) / (2 * a);

    float dist = (smaller >= 0.0) ? smaller : larger;
    if (dist < 0.0) { return false; }

    vec3 norm_intersection = norm_ray.start + dist * norm_ray.dir;
    intersection_point = (sphere.transform * vec4(norm_intersection, 1.0)).xyz;
    return true;
}

vec3 sphere_normal(Object sphere, vec3 point) {
    // Affine transformations don't preserve normal vectors
    // so we can't do inverse_transform > find normal > transform

    // TODO: this works with translation and scaling, but it may
    // break under rotation
    vec3 center = (sphere.transform * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec3 abc = (sphere.transform * vec4(1.0, 1.0, 1.0, 0.0)).xyz;
    return normalize(2.0 * (point - center) / (abc * abc));
}

vec3 point_light_sample(PointLight light) {
    return light.pos;
}
