#version 450
#extension GL_ARB_separate_shader_objects : enable

const int WIDTH = 800;
const int HEIGHT = 600;
const int WORKGROUP_SIZE = 32;
const int N_RAYS = 2;
layout(local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

layout(binding = 0, rgba8) writeonly restrict uniform image2D work_image;

const float PI = 3.14159265358979323846264338327950288;

uint RNG_STATE = 0;

float sin_rand() {
    vec2 co = vec2(float(gl_LocalInvocationIndex), float(RNG_STATE));
    RNG_STATE += 1;

    float dt = dot(co.xy, vec2(12.9898, 78.233));
    float sn = mod(dt, PI);
    return fract(sin(sn) * 43758.5453);
}

float sq(float x) {
    return x * x;
}

/// Pick a random point in the unit disc with uniform probability.
vec2 random_unit_disc_sample() {
    // see http://mathworld.wolfram.com/DiskPointPicking.html
    float angle = sin_rand() * 2.0 * PI;
	float rad = sqrt(sin_rand());
	return vec2(sin(angle) * rad, cos(angle) * rad);
}

/// Generates a random orthonormal basis based on an input vector.
///
/// Generates vectors `ray1` and `ray2` such that together with `in_ray` they
/// form an orthonormal system in 3D (all vectors are unit, and are mutually orthogonal).
///
/// `in_ray` must be a unit vector.
void orthonormal_system(vec3 in_ray, out vec3 ray1, out vec3 ray2) {
	const vec3 FIXED_SAMPLES[2] = vec3[2](
        vec3(-0.267261242, +0.534522484, -0.801783726),
		vec3(+0.483368245, +0.096673649, +0.870062840)
    );

	if (abs(dot(in_ray, FIXED_SAMPLES[0])) < 0.99) {
        ray1 = normalize(cross(in_ray, FIXED_SAMPLES[0]));
        ray2 = normalize(cross(in_ray, ray1));
    } else {
        ray1 = normalize(cross(in_ray, FIXED_SAMPLES[1]));
        ray2 = normalize(cross(in_ray, ray1));
    }
}

struct Ray {
    vec3 start;
    vec3 dir;
};

Ray screen_ray(uvec2 pixel) {
    const float ASPECT_RATIO = float(HEIGHT) / float(WIDTH);

    vec3 origin = vec3(
        (-1.0 + float(pixel.x) / float(WIDTH) * 2.0),
        (-1.0 + float(pixel.y) / float(HEIGHT) * 2.0) * ASPECT_RATIO,
        0.0
    );

    // TODO: -Z should be calculated from FoV
    vec3 dir = normalize(origin - vec3(0.0, 0.0, -10.0));

    return Ray(origin, dir);
}

struct Material {
    float refr_index;
    float glossiness;
    vec3 color;
};

float brdf_eval(Material material, vec3 w_in, vec3 w_out, vec3 normal) {
    if (dot(w_in, w_out) < 0) {
        return 0.0;
    } else {
        // TODO: this is probably not accurate
        return pow(dot(w_out, normal), 1 / (1 - material.glossiness));
    }
}

///
///
/// Assumes `w_in` and `normal` are normalized vectors
void brdf_spawn_ray(Material material, vec3 w_in, vec3 normal, float medium_refr_index, out vec3 w_out, out float prob) {
    float n1, n2;

    if (dot(w_in, normal) >= 0.0) {
        n1 = medium_refr_index;
        n2 = material.refr_index;
    } else {
        n1 = material.refr_index;
        n2 = medium_refr_index;
        normal = -normal;
    }

    // vec3 e2, e3;
    // orthonormal_system(normal, e2, e3);

    // // float scaling = tan(1 - material.glossiness * PI / 2);
    // float scaling = 1 - material.glossiness;
    // vec2 disc_sample = scaling * random_unit_disc_sample();
    // vec3 modified_normal = normalize(normal + disc_sample.x * e2 + disc_sample.y * e3);
    vec3 modified_normal = normal;

    // check if the ray reflects or refracts
    // // using Schlick's approximation
    // float r0 = (n1 - n2) / (n1 + n2) * (n1 - n2) / (n1 + n2);
    // float cos_theta_in = dot(w_in, normal);
    // float probablity_of_reflection = r0 + (1 - r0) * pow(1 - cos_theta_in, 5);

    // using Fresnel's equations
    float cos_in = dot(w_in, modified_normal);
    float sin_out_sq = (n1 / n2) * (n1 / n2) * (1 - cos_in * cos_in);
    float cos_out = sqrt(1 - sin_out_sq);

    float refl_s_polarized = sq((n1 * cos_in - n2 * cos_out) / (n1 * cos_in + n2 * cos_out));
    float refl_p_polarized = sq((n1 * cos_out - n2 * cos_in) / (n1 * cos_out + n2 * cos_in));
    float prob_of_reflection = (refl_s_polarized + refl_p_polarized) * 0.5;

    float roll = sin_rand();

    if (roll < prob_of_reflection) {
        w_out = reflect(-w_in, modified_normal);
        // TODO: calculate correct probability
        prob = prob_of_reflection * 1 / PI;
    } else {
        w_out = (n1 / n2) * (-w_in) + (n1 / n2 * cos_in - cos_out) * modified_normal;
        // TODO: calculate correct probability
        prob = 1 - prob_of_reflection;
    }
}

struct Object {
    mat4 transform;
    mat4 inv_transform;
    Material material;
};

bool sphere_intersect(Object sphere, Ray ray, out vec3 intersection_point) {
    Ray norm_ray = Ray(
        (sphere.inv_transform * vec4(ray.start, 1.0)).xyz,
        normalize((sphere.inv_transform * vec4(ray.dir, 0.0)).xyz)
    );

    // X^2 + X * 2 * dot(start, dir) + dot(start, start) - 1 = 0
    float a = 1.0;
    float b = 2 * dot(norm_ray.start, norm_ray.dir);
    float c = dot(norm_ray.start, norm_ray.start) - 1;
    float disc = b*b - 4*a*c;

    if (disc < 0) { return false; }

    float sqrt_disc = sqrt(disc);
    float smaller = (-b - sqrt_disc) / (2 * a);
    float larger = (-b + sqrt_disc) / (2 * a);

    float dist = (smaller >= 0.0) ? smaller : larger;
    if (dist < 0.0) { return false; }

    vec3 norm_intersection = norm_ray.start + dist * norm_ray.dir;
    intersection_point = (sphere.transform * vec4(norm_intersection, 1.0)).xyz;
    return true;
}

vec3 sphere_normal(Object sphere, vec3 point) {
    // Affine transformations don't preserve normal vectors
    // so we can't do inverse_transform > find normal > transform

    // TODO: this works with translation and scaling, but it may
    // break under rotation
    vec3 center = (sphere.transform * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
    vec3 abc = (sphere.transform * vec4(1.0, 1.0, 1.0, 0.0)).xyz;
    return normalize(2.0 * (point - center) / (abc * abc));
}

struct PointLight {
    vec3 pos;
    vec3 color;
};

vec3 point_light_sample(PointLight light) {
    return light.pos;
}

const Object SPHERES[2] = Object[2](
    Object(
        mat4(
            0.3, 0.0, 0.0, 0,
            0.0, 0.3, 0.0, 0,
            0.0, 0.0, 0.3, 0,
            -0.5, -0.2, 1.5, 1
        ),
        mat4(
            3.33333, 0.0, 0.0, 0,
            0.0, 3.33333, 0.0, 0,
            0.0, 0.0, 3.33333, 0,
            1.66667, 0.66667, -5, 1
        ),
        Material(100, 0.01, vec3(1.0, 0.8, 0.8))
    ),
    // Object(
    //     mat4(
    //         0.8, 0.0, 0.0, 0,
    //         0.0, 0.3, 0.0, 0,
    //         0.0, 0.0, 0.3, 0,
    //         0.0, -0.3, 2.5, 1
    //     ),
    //     mat4(
    //         1.25, 0.0, 0.0, 0,
    //         0.0, 3.33333, 0.0, 0,
    //         0.0, 0.0, 3.33333, 0,
    //         0.0, 1, -8.3333, 1
    //     ),
    //     Material(1000, 0.3, vec3(0.25, 0.9, 0.25))
    // )
    Object(
        mat4(
            0.3, 0.0, 0.0, 0,
            0.0, 0.3, 0.0, 0,
            0.0, 0.0, 0.3, 0,
            0.5, -0.2, 1.5, 1
        ),
        mat4(
            3.33333, 0.0, 0.0, 0,
            0.0, 3.33333, 0.0, 0,
            0.0, 0.0, 3.33333, 0,
            -1.66667, 0.66667, -5, 1
        ),
        Material(100, 0.03, vec3(0.25, 0.9, 0.25))
    )
);

const PointLight LIGHTS[1] = PointLight[1](
    PointLight(vec3(-1.4, -1.3, -2), vec3(1, 1, 3))
    // PointLight(vec3(-0.9, -0.9, 0.6), vec3(1, 1, 3))
);

const vec3 SPHERE_COLOR = vec3(0.5, 0.0, 0.0);

struct IntersectionInfo {
    int object;
    vec3 point;
    float dist;
};

IntersectionInfo trace_ray(Ray ray) {
    IntersectionInfo info = IntersectionInfo(-1, vec3(0, 0, 0), 1.0 / 0.0);

    for (uint i = 0; i < SPHERES.length(); i++) {
        Object object = SPHERES[i];
        vec3 intersection_point;

        if (sphere_intersect(object, ray, intersection_point)) {
            float dist_to_intersection = distance(ray.start, intersection_point);

            if (dist_to_intersection < info.dist) {
                info = IntersectionInfo(int(i), intersection_point, dist_to_intersection);
            }
        }
    }

    return info;
}

void main() {
    // In order to fit the work into workgroups, some unnecessary threads are launched.
    if (gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT) { return; }

    RNG_STATE = gl_GlobalInvocationID.z * 1000;

    Ray ray = screen_ray(gl_GlobalInvocationID.xy);
    vec3 out_color = vec3(0.0, 0.0, 0.0);
    vec3 light_mult = vec3(1.0, 1.0, 1.0);

    const vec3 BACKGROUND_COLOR = vec3(0.1, 0.1, 0.1);
    const uint MAX_DEPTH = 8;

    for (uint i = 0; i < MAX_DEPTH; i++) {
        IntersectionInfo intersect = trace_ray(ray);

        if (intersect.object == -1) {
            out_color += BACKGROUND_COLOR * light_mult;
            break;
        }

        Object obj = SPHERES[intersect.object];
        vec3 obj_normal = sphere_normal(obj, intersect.point);

        // Trace ray from intersection to a light source
        vec3 light_sample = point_light_sample(LIGHTS[0]);
        float dist_to_light = distance(light_sample, intersect.point);
        Ray light_ray = Ray(intersect.point + 0.000061035 * obj_normal, normalize(light_sample - intersect.point));
        IntersectionInfo light_intersect = trace_ray(light_ray);

        if (dist_to_light < light_intersect.dist) {
            float prob = brdf_eval(obj.material, -ray.dir, light_ray.dir, obj_normal);
            out_color += LIGHTS[0].color * obj.material.color * light_mult * prob;
        }

        // Continue tracing the original ray
        vec3 w_out;
        float prob;
        brdf_spawn_ray(obj.material, -ray.dir, obj_normal, 1.0, w_out, prob);

        ray = Ray(intersect.point + 0.000061035 * w_out, w_out);
        light_mult *= obj.material.color * prob;
    }

    out_color /= float(N_RAYS);

    // apply gamma correction
    // TODO: do I need this, framebuffer color space is sRGB?
    // TODO: must be applied after the sum
    // out_color = pow(out_color, vec3(2.2));

    // vec4 image_color = imageLoad(work_image, ivec2(gl_GlobalInvocationID.xy));
    // imageStore(work_image, ivec2(gl_GlobalInvocationID.xy), image_color + vec4(out_color.bgr, 1.0));
    imageStore(work_image, ivec2(gl_GlobalInvocationID.xy), vec4(out_color.bgr, 1.0));
}
